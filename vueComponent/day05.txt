day05

26、todoList组件化开发（案例）
	静态页面
		1、拆分页面 定义组件
		2、将组件组装到App当中
		3、渲染组件实现静态页面
	动态页面
		1、初始化动态显示页面
			设计数据   todos = [ {id:1,content:'吃饭',isOver:false},{id:2,content:'睡觉',isOver:false}]
			数据展示   初始化todo内容展示和是否选中的展示
				   注意： 是否选中的打勾状态数据是根据todo的isOver计算而来的，需要computed去计算
				       
		2、交互（与用户的交互）
			2-1：完成鼠标移入移出删除按钮的出现和消失及背景色的改变 Item
				页面的变化其实对应的是数据的变化
			2-2: 完成添加todo逻辑 




			2-3: 点击每一项修改打勾（是否完成）操作   Item
			2-4：完成点击删除，删除某一项的操作 Item
			2-5：完成已完成和全部的数量展示 Footer    根据todos相关数据计算而来
			2-6：完成获取全选和全不选功能  全选和全不选功能checked的结果根据已完成和全部的数量计算得到



			2-7：点击设置全选和全不选，完成功能
			2-8：删除已完成功能




			2-9：刷新还是原来的效果，不会回到初始的情况（数据存储分析）
				保存什么数据   todos
				数据保存在哪   localStorage
				什么时候保存   数据只要发生改变就该存储 ===== 》 深度监视(用什么手段知道它变化的) 可以保证loclStorage里边是最新的
				什么时候读取   初始化显示就该读取，从localStorage里边取,放在data中  取到的是最新的




				localStorage的简介（永久存储，关闭和刷新浏览器，数据不会丢失）
				---为了客户端人员更好的存储数据,我们可以认为它是我们前端的一个小的数据库---存储数据
				存储在浏览器端 在Application -localStorage和sessionStorage 存储数据的地方
				这样就可以保证数据可以拿到的,只要你数据存储了，我就可以拿的到

					localStorage是h5新增的一种本地存储数据方式，本质是一个对象(存储的是键值对)
					四个API:
					setItem(key,value)  ---存储数据
					getItem(key)  如果没有返回null ---读取数据
					removeItem(key) ---删除哪一个数据
					clear() ---清空所有的
			
				cookie存储的内容比较小  --- 用来做状态保持的,
					是因为浏览器端发送请求服务器端不认识,需要用cookie和session做状态保持,能够让服务器端能够认识服务器端两个请求时同一个客户发的
					服务器不认识两次发请求的是一个人,为了做到状态保持,出现了cookie
					
					cookie为了做到状态保持,带了一段文字到服务器,服务器接收到请求一看这两次的文字是一样的,那就是同一个人
					状态保持就是看你是不是一个人
					后来因为cookie安全性太不好了,人稍微一抓包就拿走了,而且把你的用户名密码看的清清楚楚,所以才出现了session

					session是谁的解决手段:session是服务器的解决手段	,服务器一般会在一个数据库里边,或者说是在服务器的一个文件里边去存储一个sesssion_Key
					当你第一次登录的时候,我们的服务端接收的请求会根据你的用户名和密码通过一个特殊的算法算出一个随机的字符串,而那个随机的字符串叫session_Key
					然后给你返回响应的时候会把那个session_Key给你带回来给用户,而用户会把session_key放在cookie里边传回去,
					这样就算抓包也只能拿到一个随机的字符串而拿不到用户名和密码
					session只是做安全性的保障
					但是session是依赖于cookie的
					cookie和session都是可以设置过期时间的,默认是7天

			2-10：一般监视和深度监视
				一般监视：
					数组本身发生改变
					数组内部元素整体改变
				深度监视：
					数组本身发生改变
					数组内部元素整体改变
					数组内部元素内部数据改变

			2-11：深度监视数据，保存
				数据需要变为json然后取存储，否则数据下次取到的就看不懂了内部会调用对象的toString，数据变了
			
			2-12：在data数据中，直接从localStorage中获取数据






27、	组件化编码的基本规范
	子组件里面不要去更新父组件当中的数据
	1、分析数据在哪个组件
	2、数据在哪个组件，那么更新数据的行为（方法）就在哪个组件
	3、父组件的数据传递给子组件，是用来让子组件读取显示使用的，而不是让子组件去修改的（可以但是不该）
	4、子组件需要更新数据，那么需要调用父组件传递过来的更新数据方法



props三种写法：
	通信的时候，只能是父子之间

	第一种接收属性写法
	props: ['index']
	第二种接收属性写法
	props:{
		index:Number
	}
	第三种接收属性写法
	props:{

		index:{
			type:Number,
			default:0
		}
	}



自定义事件组件间通信深入理解：
	
	zhaoliying
	onclick



	自定义事件：自己定义的事件：事件类型（自己定义,无数个）和回调函数（自己定义自己触发,自己调）

    系统定义的事件：事件类型（固定几个）和回调函数（自己定义系统触发/浏览器调）
					onclick  onmousemove onkeyup
	回调函数需要自己写 定义都是自己定义的
	系统定义：回调函数是浏览器帮你调的
	自定义事件:回调函数是自己调的




			
	做法：在父组件当中可以看到子组件对象，给子组件对象绑定自定义事件$on  回调函数在父组件中

	      在子组件当中，我们需要传递数据的地方，去触发自己身上的事件$emit，调用回调函数中传参给父



	适用：子向父通信
	原因：因为父组件内部可以看到子组件对象，可以给子组件对象绑定事件，回调函数在父组件定义
	      	
	

	接受数据的组件必须能看到预绑定事件的组件对象，才能绑定
	发送数据的组件必须能看到绑定了事件的组件对象，才能触发事件

	$on
	$emit

	$off   //解绑事件  在你需要销毁实例的时候，我们可以善后处理一下
	$once  //绑定只能触发一次的事件

	都是Vue的显式原型身上的方法


全局事件总线组件间通信
	适用于任意组件间传递  必须理解必须搞定
	利用了自定义事件
		创建一个中间人，让所有的组件都可以看到这个人，并且这个人可以使用$on和$emit   （vm添加到Vue原型当中作为总线）
		在想要接受数据的组件内 找中间人去绑定事件
		在想要发送数据的组件内 触发中间人绑定的事件	
		